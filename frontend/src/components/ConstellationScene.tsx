import React, { useMemo } from 'react';
import { NeonWispNode } from './NeonWispNode';
import { EnergyConnection, DataFlowBeam } from './EnergyConnection';

interface ConstellationSceneProps {
  graph: {
    nodes: Array<{
      id: string;
      kind?: string;
      label?: string;
      summary?: string;
      degree?: number;
      ts?: number;
      x?: number;
      y?: number;
      z?: number;
      size?: number;
      importance?: number;
    }>;
    edges: Array<{
      source: string;
      target: string;
      rel?: string;
      weight?: number;
      ts?: number;
    }>;
  };
  onSelect: (node: any) => void;
  positions: Map<string, [number, number, number]>;
}

export function ConstellationScene({ graph, onSelect, positions }: ConstellationSceneProps) {
  // Enhanced node rendering with neon wisps
  const nodeElements = useMemo(() => {
    return graph.nodes.map((node) => {
      const pos = positions.get(node.id) || [
        (node.x || 0) * 10,
        (node.y || 0) * 10,
        (node.z || 0) * 10
      ];
      
      // Determine color based on node type and importance
      let color = '#4A90E2'; // Default blue
      let glowIntensity = 0.5;
      
      switch (node.kind) {
        case 'glyph':
          color = '#B19CD9'; // Purple for glyphs
          glowIntensity = 0.8;
          break;
        case 'concept':
          color = '#4ecdc4'; // Cyan for concepts
          glowIntensity = 0.7;
          break;
        case 'entity':
          color = '#ff6b9d'; // Pink for entities
          glowIntensity = 0.6;
          break;
        case 'cluster':
          color = '#f9ca24'; // Gold for clusters
          glowIntensity = 0.9;
          break;
        default:
          color = '#45b7d1'; // Light blue for messages
          break;
      }
      
      const importance = node.importance || 0;
      const size = (node.size || 1) * (1 + importance * 0.5);
      
      return (
        <NeonWispNode
          key={node.id}
          position={pos as [number, number, number]}
          color={color}
          size={size}
          glow={glowIntensity + importance * 0.3}
          importance={importance}
          onClick={() => onSelect(node)}
          onHover={(hovered) => {
            // TODO: Add hover effects
          }}
        />
      );
    });
  }, [graph.nodes, positions, onSelect]);
  
  // Enhanced edge rendering with energy connections
  const edgeElements = useMemo(() => {
    const nodePositions = new Map();
    graph.nodes.forEach(node => {
      const pos = positions.get(node.id) || [
        (node.x || 0) * 10,
        (node.y || 0) * 10,
        (node.z || 0) * 10
      ];
      nodePositions.set(node.id, pos);
    });
    
    return graph.edges.map((edge, index) => {
      const startPos = nodePositions.get(edge.source);
      const endPos = nodePositions.get(edge.target);
      
      if (!startPos || !endPos) return null;
      
      // Determine connection properties based on relationship
      let color = '#2b313d';
      let thickness = 1.0;
      let animationSpeed = 1.0;
      let autoGenerated = false;
      
      switch (edge.rel) {
        case 'semantic_similarity':
          color = '#00ff88';
          autoGenerated = true;
          animationSpeed = 1.5;
          break;
        case 'causal':
          color = '#ff6b9d';
          thickness = 1.5;
          animationSpeed = 0.8;
          break;
        case 'temporal':
          color = '#4ecdc4';
          thickness = 0.8;
          animationSpeed = 2.0;
          break;
        case 'structural':
          color = '#f9ca24';
          thickness = 1.2;
          animationSpeed = 0.6;
          break;
        default:
          color = '#45b7d1';
          break;
      }
      
      const weight = edge.weight || 1.0;
      const opacity = Math.max(0.3, Math.min(1.0, weight));
      
      return (
        <EnergyConnection
          key={`${edge.source}-${edge.target}-${index}`}
          start={startPos as [number, number, number]}
          end={endPos as [number, number, number]}
          color={color}
          thickness={thickness * weight}
          opacity={opacity}
          animationSpeed={animationSpeed}
          autoGenerated={autoGenerated}
        />
      );
    }).filter(Boolean);
  }, [graph.edges, graph.nodes, positions]);
  
  // Add data flow animations for high-importance connections
  const dataFlowElements = useMemo(() => {
    const nodePositions = new Map();
    graph.nodes.forEach(node => {
      const pos = positions.get(node.id) || [
        (node.x || 0) * 10,
        (node.y || 0) * 10,
        (node.z || 0) * 10
      ];
      nodePositions.set(node.id, pos);
    });
    
    // Only show data flows for high-weight connections
    return graph.edges
      .filter(edge => (edge.weight || 0) > 0.7)
      .slice(0, 10) // Limit for performance
      .map((edge, index) => {
        const startPos = nodePositions.get(edge.source);
        const endPos = nodePositions.get(edge.target);
        
        if (!startPos || !endPos) return null;
        
        return (
          <DataFlowBeam
            key={`flow-${edge.source}-${edge.target}-${index}`}
            start={startPos as [number, number, number]}
            end={endPos as [number, number, number]}
            color={'#00ff88'}
            speed={2.0}
          />
        );
      })
      .filter(Boolean);
  }, [graph.edges, graph.nodes, positions]);
  
  return (
    <group>
      {/* Render all nodes as neon wisps */}
      {nodeElements}
      
      {/* Render all edges as energy connections */}
      {edgeElements}
      
      {/* Render data flow animations */}
      {dataFlowElements}
    </group>
  );
}