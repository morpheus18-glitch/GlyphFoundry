import React, { useRef, useMemo } from 'react';
import * as THREE from 'three';
import { useFrame } from '@react-three/fiber';
import { Line } from '@react-three/drei';

interface EnergyConnectionProps {
  start: [number, number, number];
  end: [number, number, number];
  color: string;
  thickness: number;
  opacity: number;
  animationSpeed: number;
  autoGenerated?: boolean;
}

// Energy beam shader for flowing connections
const energyVertexShader = `
  attribute float progress;
  varying float vProgress;
  varying vec2 vUv;
  
  void main() {
    vProgress = progress;
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const energyFragmentShader = `
  uniform float time;
  uniform vec3 energyColor;
  uniform float intensity;
  uniform float speed;
  varying float vProgress;
  varying vec2 vUv;
  
  void main() {
    // Create flowing energy effect
    float flow = sin(vProgress * 10.0 - time * speed) * 0.5 + 0.5;
    float pulse = sin(time * 3.0) * 0.3 + 0.7;
    
    // Edge falloff for smooth beam
    float edgeFalloff = 1.0 - abs(vUv.y - 0.5) * 2.0;
    edgeFalloff = smoothstep(0.0, 0.8, edgeFalloff);
    
    // Combine effects
    float finalIntensity = flow * pulse * edgeFalloff * intensity;
    
    gl_FragColor = vec4(energyColor * finalIntensity, finalIntensity);
  }
`;

export function EnergyConnection({
  start,
  end,
  color,
  thickness,
  opacity,
  animationSpeed,
  autoGenerated = false
}: EnergyConnectionProps) {
  const beamRef = useRef<THREE.Mesh>(null);
  const particlesRef = useRef<THREE.Points>(null);
  
  const [geometry, particleGeometry, uniforms] = useMemo(() => {
    // Create curved path for the energy beam
    const startVec = new THREE.Vector3(...start);
    const endVec = new THREE.Vector3(...end);
    const distance = startVec.distanceTo(endVec);
    
    // Add slight curve for more organic feel
    const midPoint = startVec.clone().add(endVec).multiplyScalar(0.5);
    const curvature = distance * 0.1;
    midPoint.y += curvature * (Math.random() - 0.5);
    
    // Create curve path
    const curve = new THREE.QuadraticBezierCurve3(startVec, midPoint, endVec);
    const points = curve.getPoints(64);
    
    // Create tube geometry for the beam
    const tubeGeometry = new THREE.TubeGeometry(
      new THREE.CatmullRomCurve3(points),
      64,
      thickness * 0.5,
      8,
      false
    );
    
    // Add progress attribute for shader animation
    const progressArray = new Float32Array(tubeGeometry.attributes.position.count);
    for (let i = 0; i < progressArray.length; i++) {
      progressArray[i] = (i % 64) / 64;
    }
    tubeGeometry.setAttribute('progress', new THREE.BufferAttribute(progressArray, 1));
    
    // Create particle system along the path
    const particleCount = Math.floor(distance / 5) + 5;
    const particlePositions = new Float32Array(particleCount * 3);
    const particleSizes = new Float32Array(particleCount);
    
    for (let i = 0; i < particleCount; i++) {
      const t = i / (particleCount - 1);
      const point = curve.getPoint(t);
      
      particlePositions[i * 3] = point.x;
      particlePositions[i * 3 + 1] = point.y;
      particlePositions[i * 3 + 2] = point.z;
      
      particleSizes[i] = thickness * (0.5 + Math.random() * 0.5);
    }
    
    const particleGeometry = new THREE.BufferGeometry();
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
    
    // Shader uniforms
    const uniforms = {
      time: { value: 0 },
      energyColor: { value: new THREE.Color(autoGenerated ? '#00ff88' : color) },
      intensity: { value: opacity * (autoGenerated ? 1.5 : 1.0) },
      speed: { value: animationSpeed }
    };
    
    return [tubeGeometry, particleGeometry, uniforms];
  }, [start, end, color, thickness, opacity, animationSpeed, autoGenerated]);
  
  useFrame((state) => {
    const time = state.clock.elapsedTime;
    
    if (beamRef.current) {
      uniforms.time.value = time;
    }
    
    if (particlesRef.current) {
      // Animate particles along the beam
      const positions = particleGeometry.attributes.position.array as Float32Array;
      for (let i = 0; i < positions.length; i += 3) {
        const offset = (time * animationSpeed + i * 0.01) % (Math.PI * 2);
        positions[i + 1] += Math.sin(offset) * 0.1;
      }
      particleGeometry.attributes.position.needsUpdate = true;
    }
  });
  
  return (
    <group>
      {/* Main energy beam */}
      <mesh ref={beamRef} geometry={geometry}>
        <shaderMaterial
          vertexShader={energyVertexShader}
          fragmentShader={energyFragmentShader}
          uniforms={uniforms}
          transparent={true}
          blending={THREE.AdditiveBlending}
        />
      </mesh>
      
      {/* Flowing particles */}
      <points ref={particlesRef} geometry={particleGeometry}>
        <pointsMaterial
          size={thickness * 0.3}
          color={autoGenerated ? '#00ff88' : color}
          transparent={true}
          opacity={opacity * 0.8}
          blending={THREE.AdditiveBlending}
          sizeAttenuation={true}
        />
      </points>
      
      {/* Core line for stability */}
      <Line
        points={[start, end]}
        color={autoGenerated ? '#00ff88' : color}
        lineWidth={thickness * 0.2}
        transparent={true}
        opacity={opacity * 0.5}
      />
    </group>
  );
}

// Component for data flow visualization
export function DataFlowBeam({
  start,
  end,
  color = '#4ecdc4',
  speed = 2.0
}: {
  start: [number, number, number];
  end: [number, number, number];
  color?: string;
  speed?: number;
}) {
  const flowRef = useRef<THREE.Points>(null);
  
  const [flowGeometry, flowMaterial] = useMemo(() => {
    const startVec = new THREE.Vector3(...start);
    const endVec = new THREE.Vector3(...end);
    
    // Create data packets along the path
    const packetCount = 8;
    const positions = new Float32Array(packetCount * 3);
    const sizes = new Float32Array(packetCount);
    
    for (let i = 0; i < packetCount; i++) {
      const t = i / packetCount;
      const point = startVec.clone().lerp(endVec, t);
      
      positions[i * 3] = point.x;
      positions[i * 3 + 1] = point.y;
      positions[i * 3 + 2] = point.z;
      
      sizes[i] = 2 + Math.random() * 2;
    }
    
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    
    const material = new THREE.PointsMaterial({
      color: color,
      size: 3,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending
    });
    
    return [geometry, material];
  }, [start, end, color]);
  
  useFrame((state) => {
    if (flowRef.current) {
      const time = state.clock.elapsedTime * speed;
      const positions = flowGeometry.attributes.position.array as Float32Array;
      const startVec = new THREE.Vector3(...start);
      const endVec = new THREE.Vector3(...end);
      
      for (let i = 0; i < positions.length; i += 3) {
        const packetIndex = i / 3;
        const t = ((time + packetIndex * 0.2) % 2.0) / 2.0;
        const point = startVec.clone().lerp(endVec, t);
        
        positions[i] = point.x;
        positions[i + 1] = point.y;
        positions[i + 2] = point.z;
      }
      
      flowGeometry.attributes.position.needsUpdate = true;
    }
  });
  
  return (
    <points ref={flowRef} geometry={flowGeometry} material={flowMaterial} />
  );
}